---
layout: post
title: Downsampling avec Influxdb v1 et Grafana
author:
  name: iroco
categories:
- Sous le capot
tags:
- monitoring
---

![Image d'un Ã¢ne soulevÃ© par une charrette trop pleine](/images/over-delivering-donkey.jpg)

_Suite Ã  [notre sÃ©rie](/monitoring-conclusion/) sur les outils ouverts de monitoring nous avons mis en production [collectd](https://collectd.org/)/[Influxdb V1](https://docs.influxdata.com/influxdb/v1/)/[grafana](https://grafana.com/) mais la question de gestion des donnÃ©es de monitoring s'est rapidement posÃ©e. Nous allons vous parler de deux fonctionalitÃ©s des bases de donnÃ©es temporelles : le sous-Ã©chantillonnage et les politiques de rÃ©tention._


La mise en production notre systÃ¨me de monitoring [collectd](https://collectd.org/)/[Influxdb V1](https://docs.influxdata.com/influxdb/v1/)/[grafana](https://grafana.com/) nous a posÃ© une nouvelle question : 

> Comment faire pour ne pas stocker indÃ©finiment toutes les donnÃ©es enregistrÃ©es sur l'espace disque ?

En effet, au rythme de chaque mÃ©trique toutes les 5 min, notre systÃ¨me de monitoring risque de prendre de plus en plus de place sur nos serveurs.

Afin de rÃ©soudre ce problÃ¨me, nous avons dÃ» nous informer sur deux nouveau concepts pour nous, le sous-Ã©chantillonnage (_downsampling_) de donnÃ©es temporelles (_time series_)  et la mise en place de politiques de rÃ©tention.

Le principe est simple : comme l'intÃ©rÃªt de la prÃ©cision des donnÃ©es diminue avec le temps, il suffit de la rÃ©duire au delÃ  de certaines dates. A quoi cela nous servirait-il d'avoir des donnÃ©es toutes les 5 minutes pour le mois de septembre 2021 ? En revanche, c'est intÃ©ressant d'avoir des tendances globales pour comprendre et anticiper les Ã©volutions futures du service. 

Par exemple, nous conservons les traces applicatives pendant un mois. Nous souhaitons conserver la meilleure prÃ©cision des indicateurs dont nous disposons pendant cette pÃ©riode : si nous constatons un incident, nous avons un maximum d'information pour _dÃ©bugger_ un Ã©ventuel dysfonctionnement, une attaque ou une fausse manipulation.

Nous avons dÃ©cidÃ© d'opter pour 3 granularitÃ©s : 

- 5 minutes (conservation de toutes les donnÃ©es collectÃ©es) pour les 30 derniers jours afin de rÃ©soudre nos problÃ¨mes d'exploitation ;
- 1 heure pendant les 6 derniers mois pour voir les tendances d'Ã©volution de maniÃ¨re relativement fine ;
- 1 jour sur les 5 derniÃ¨res annÃ©es pour un historique plus long terme de nos services.

Nous estimons que les donnÃ©es plus anciennes ne valent pas la peine dâ€™Ãªtre conservÃ©es.

La [documentation officielle d'InfluxDB](https://docs.influxdata.com/influxdb/v1/guides/downsample_and_retain/)  nous explique comment faire pour mettre en place ces nouveaux besoins.

# Les [Retention Policies](https://docs.influxdata.com/influxdb/v1/query_language/manage-database/#retention-policy-management) InfluxDB
    
Elles indiquent le temps qu'une donnÃ©es sera conservÃ©e. Il est possible d'en crÃ©er autant que de pÃ©riodes pendant lesquelles vous voulez conserver un groupe de donnÃ©es avec une certaine granularitÃ©.
  
Par dÃ©faut, lors de la crÃ©ation d'une base de donnÃ©es, InfluxDB gÃ©nÃ¨re une retention policy "autogen" dans laquelle sont insÃ©rÃ©es toutes les donnÃ©es sur une durÃ©e infinie.

Nous allons donc dÃ©finir trois _retention policies_ :  30 jours, 6 mois, 5 ans :

```sql
ALTER RETENTION POLICY "autogen" ON "database" DURATION 30d REPLICATION 1  DEFAULT
CREATE RETENTION POLICY "6_months" ON "database" DURATION 26w REPLICATION 1
CREATE RETENTION POLICY "5_years" ON "database" DURATION 260w REPLICATION 1
```

Nous modifions la RP "autogen" pour qu'elle ait une durÃ©e de rÃ©tention de 30 jours (Attention, toutes les donnÃ©es plus anciennes de 30 jours seront directement supprimÃ©es aprÃ¨s avoir fait cette modification).

Ensuite, nous crÃ©ons deux nouvelles RP sur cette base de donnÃ©e, une `6_months` d'une durÃ©e de 26 semaines et une `5_years` d'une durÃ©e de 260 semaines.

Si vous avez dÃ©jÃ  des donnÃ©es de plus de 30 jours, nous vous conseillons de commencer par crÃ©er les deux RP `6_months` et `5_years` et de _downsampler_ les donnÃ©es depuis `autogen`   avec les requÃªtes suivantes:
```sql
SELECT mean(value) AS value INTO my_database."6_months".my_measurement FROM my_database."autogen".my_measurement WHERE time > now() - 26w GROUP BY time(1h), *
SELECT mean(value) AS value INTO my_database."5_years".my_measurement FROM my_database."autogen".my_measurement WHERE time > now() - 260w GROUP BY time(1d), *
```
Vous pourrez ensuite modifier la duration de "autogen" sans rien avoir perdu.

# Les [Continuous Queries](https://docs.influxdata.com/influxdb/v1/query_language/continuous_queries/) InfluxDB
   
Ce sont des requÃªtes InfluxQl qui sont exÃ©cutÃ©es automatiquement par influxdb. Elles doivent contenir un `SELECT ... GROUP BY time()` qui dÃ©finit Ã  la fois la granularitÃ© de _downsampling_ ainsi que les moments oÃ¹ elles seront appelÃ©es. `GROUP BY time(1h)`  sera exÃ©cutÃ©e Ã  la fin de chaque heure et agrÃ©gera les donnÃ©es de l'heure qui vient de s'Ã©couler pour les insÃ©rer dans un autre _measurement_ (Ã©quivalent d'une table SQL).

Attention, si vous crÃ©ez une _continuous query_ sur les donnÃ©es existantes d'un  _measurement_, celles-ci ne seront pas agrÃ©gÃ©es automatiquement. Il sera nÃ©cessaire de faire une insertion manuelle (comme les deux requÃªtes ci-dessus). Seules les donnÃ©es du dernier intervalle dÃ©fini dans `GROUP BY time(interval)` et les suivantes seront prises en comptes.

Nous n'avons pas trouvÃ© de moyen de crÃ©er des CQ's qui s'appliqueraient Ã  tous les _measurements_ d'une base de donnÃ©es. Il vous sera donc nÃ©cessaire d'ajouter une CQ pour chaque _measurement_.

Pour un _measurement_ nous avons donc ceci:

```sql
CREATE CONTINUOUS QUERY "cq_my_measurement_6_months" ON "my_database" 
BEGIN
  SELECT mean(value) AS value
  INTO "6_months"."my_measurement"
  FROM "autogen"."my_measurement"
  GROUP BY time(1h)
  , *
END

CREATE CONTINUOUS QUERY "cq_my_measurement_5_years" ON "my_database"
BEGIN
  SELECT mean(value) AS value
  INTO "5_years"."my_measurement"
  FROM "autogen"."my_measurement"
  GROUP BY time(1d)
  , *
END
```
notes: 
- `AS` permet de conserver le nom du champ car Influxdb ajoute mean_ par dÃ©faut. Cela est nÃ©cessaire pour simplifier la configuration grafana.
- Le `, *` permet de distinguer par `tag::type_instance` lors du `GROUP BY`.

Une fois les RP's et les CQ's crÃ©Ã©es, InfluxDB gÃ¨re automatiquement le Downsampling.


# La visualisation avec Grafana

Grafana vas chercher les donnÃ©es d'un graphique dans un _measurement_. Si vous avez un graphique reprÃ©sentant `autogen.my_measurement` avec la configuration InfluxDB prÃ©cÃ©dente, vous n'aurez donc accÃ¨s qu'aux donnÃ©es des 30 derniers jours. Si vous voulez voir les donnÃ©es des 6 derniers mois il faudra relier un autre graphique au _measurement_ `6_months.my_measurement`. ðŸ¤”

> Comment faire pour afficher les donnÃ©es des 3 diffÃ©rentes granularitÃ©s dans un seul graphique ?

Nous avons passÃ©s un certain temps pour trouver un moyen simple de naviguer entre les donnÃ©es de diffÃ©rentes granularitÃ©s depuis grafana. Nous sommes tombÃ©s sur [un message dans une issue github](https://github.com/grafana/grafana/issues/4262#issuecomment-475570324) qui prÃ©sentait une solution Ã©lÃ©gante.

L'objectif est de trouver un moyen de contourner le fait que grafana ne soit pas capable de gÃ©rer des variables conditionnelles. Ici, il dÃ©finit une retention policy "forever" infinie et insÃ¨re 3 correspondances entre des tailles de fenÃªtre temporelle et les RPs:

```sql
CREATE RETENTION POLICY "forever" ON my_database DURATION INF REPLICATION 1
INSERT INTO forever rp_config,idx=1 rp="autogen",start=0i,end=2592000000i -9223372036854775806
INSERT INTO forever rp_config,idx=2 rp="6_months",start=2592000000i,end=11321856000i -9223372036854775806
INSERT INTO forever rp_config,idx=3 rp="5_years",start=11321856000i,end=271724544000i -9223372036854775806
```

Voyons en dÃ©tail ce que font ces requÃªtes selon la [doc infuxdb](https://docs.influxdata.com/influxdb/v1/write_protocols/line_protocol_tutorial/):
- `forever` : la retention policy crÃ©Ã©e pour stocker les diffÃ©rentes fenÃªtres temporelles.
- `rp_config` : un _measurement_ `rp_config` crÃ©Ã© pour la gestion de ces fenÃªtre. Nous crÃ©ons 3 enregistrements dans ce _measurement_.
- `idx=1` : c'est un tag d'index avec la valeur 1 (il n'est pas obligatoire mais il sert Ã  ordonner les 3 diffÃ©rentes granularitÃ©s)
- `rp="autogen,start=0i,end=2592000000i` : ce sont les champs (_fields_)  du measurement. Rp est le nom de la RP, start et end dÃ©finissent la taille de fenÃªtre (en ms) pour laquelle mapper la RP. Le `i` dÃ©signe le type de la donnÃ©e : un entier.
- `-9223372036854775806` : câ€™est lâ€™horodatage (timestamp) du point Ã©crit (en ns). Obligatoire car influxdb ne peut stocker que des donnÃ©es temporelles. La faible valeur (-272 annÃ©es) correspond Ã  la [date minimale gÃ©rÃ©e par Influxdb](https://github.com/influxdata/influxdb-java/issues/626) (max 64 bits). Elle ne pourra pas interfÃ©rer avec d'autres donnÃ©es. Grafana ne la voit pas.

Une fois la RP `forever` ainsi configurÃ©e, il suffit de crÃ©er une variable grafana qui rÃ©cupÃ¨re la bonne `rp_config` en fonction de la taille de la fenÃªtre d'affichage de grafana : 

```sql
SELECT rp FROM forever.rp_config WHERE $__to-$__from > start and $__to-$__from <= "end"
```
DÃ©taillons la requÃªte :
- `SELECT rp FROM forever.rp_config`: rÃ©cupÃ¨re l'enregistrement dans le measurement rp_config
- `$__to-$__from`: correspond Ã  la taille de la fenÃªtre actuellement observÃ©e dans grafana (en ms).
- `WHERE $__to-$__from > start and $__to-$__from <= "end"`: permet de s'assurer que la taille de la fenÃªtre est bien comprise entre la taille minimale (start) et la taille maximale (end) de fenÃªtre acceptÃ©e pour la `rp_config`.

Il ne faut pas oublier de configurer le `Refresh` pour que la variable se mette Ã  jour lorsque la fenÃªtre change.

Il suffit ensuite d'appeler cette variable dans tous les graphiques.

Bien qu'impressionnÃ©s par cette solution, aprÃ¨s l'avoir testÃ©e, nous avons constatÃ© quelques inconvÃ©nients : si on affiche les donnÃ©es d'un mois il y a un an, tout va bien, grafana fait la requÃªte sur le _measurement_ `5_years.my_measurement`. Mais si on on zoom sur une pÃ©riode de une semaine, alors il va utiliser `autogen.my_measurement` et l'affichage est cassÃ©. En d'autres termes il ne nous semble pas pertinent de faire dÃ©pendre la `rp_config`  de la taille de la fenÃªtre grafana.  Nous prÃ©fÃ©rerions que celle-ci dÃ©pende plutÃ´t de l'anciennetÃ© de la plus ancienne variable affichÃ©e dans la fenÃªtre.

Nous devons pouvoir comparer notre `$__from` au temps actuel. Malheureusement il n'existe pas de variable `$__now` ou Ã©quivalent dans grafana. Mais nous pouvons utiliser la fonction `now()` de InfluxDB. Malheureusement, cette fonction ne peut Ãªtre utilisÃ© qu'avec un filtre `WHERE time` qui compare un timestamp. Nous ne pourrons donc pas utiliser de champ comme `start` ou `end` pour nous aider. Il va falloir stocker cette information directement dans l'enregistrement.

```sql
INSERT INTO forever rp_config,idx=1 rp="autogen",group_by="5m" 2592300000000000
INSERT INTO forever rp_config,idx=2 rp="6_months",group_by="1h" 15782400000000000
INSERT INTO forever rp_config,idx=3 rp="5_years",group_by="1d" 157874400000000000
```

Nous avons gardÃ© les 3 enregistrements dans notre _measurement_ de configuration. Ce que nous avons changÃ©:
- retrait de `start` et `end` car devenus inutiles.
- ajout d'un field `group_by` permettant d'avoir directement accÃ¨s Ã  la granularitÃ© en fonction de la RP.
- utilisation du timestamp pour intÃ©grer l'anciennetÃ© maximale des donnÃ©es d'une rp (en ns Ã  partir du temps 0 informatique, le 1er janvier 1970 minuit). 

Ces queries vont insÃ©rer 3 donnÃ©es dans notre _measurement_ `rp_config` aux instants `temps 0 + 30d`, `temps 0 + 6M` et `temps 0 + 5y`  avec pour chacune un index, le nom d'une RP et une valeur de  `group_by`.

Il suffit maintenant de rÃ©cupÃ©rer ces valeurs dans Grafana:

rp:
```sql
SELECT first(rp) FROM forever.rp_config WHERE time >= (now() - ${__from}ms)
```
group_by:
```sql
SELECT first(group_by) FROM forever.rp_config WHERE time >= (now() - ${__from}ms)
```
- `first()`: permet de ne rÃ©cupÃ©rer que le premier Ã©lÃ©ment des `rp_config`  pour le dÃ©but de fenÃªtre grafana (non obligatoire mais permet d'adapter automatiquement Ã  la rÃ©solution maximale disponible pour une date donnÃ©e)
- `${__from}ms`: indique le dÃ©but de la fenÃªtre temporelle grafana actuellement observÃ©e (ms est obligatoire pour rendre compatible avec `now`, sinon sera interprÃ©tÃ© en nanosecondes)
- `now() - ${__from}ms`: calcul de la pÃ©riode avec la meilleure granularitÃ© dans influxdb
- `WHERE time >= (now() - ${__from}ms)`: ne rÃ©cupÃ¨re que les donnÃ©es pour lesquelles `time` est supÃ©rieur au dÃ©but de la fenÃªtre.

Ainsi nous avons bien un graphique par indicateur et quand nous changeons de pÃ©riode dans grafana, ou que nous zoomons sur un graphique, grafana va automatiquement sÃ©lectionner la bonne `rp_config` et utilise le prefix pour charger les donnÃ©es depuis le _measurement_ correspondant, avec la bonne granularitÃ©.

Si vous avez des remarques, des suggestions pour faire mieux, n'hÃ©sitez pas !
